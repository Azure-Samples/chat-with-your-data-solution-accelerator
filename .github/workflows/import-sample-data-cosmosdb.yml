name: Import Sample Data into CosmosDB

on:
  workflow_dispatch:
    inputs:
      RESOURCE_GROUP_NAME:
        description: 'Azure Resource Group name'
        required: true
        type: string
      AZURE_SEARCH_SERVICE:
        description: 'Azure Search service name or URL'
        required: true
        type: string
      AZURE_BLOB_ACCOUNT_NAME:
        description: 'Azure Blob Storage Account name'
        required: true
        type: string
      AZURE_SEARCH_INDEX:
        description: 'Azure Search index name (optional - will auto-detect from search service if not provided)'
        required: false
        type: string
      WAF:
        description: 'Is this a WAF deployment? (enables public access temporarily for data import and then disables it)'
        required: false
        type: boolean
        default: false
  workflow_call:
    inputs:
      RESOURCE_GROUP_NAME:
        description: 'Azure Resource Group name'
        required: true
        type: string
      AZURE_SEARCH_SERVICE:
        description: 'Azure Search service name or URL'
        required: true
        type: string
      AZURE_BLOB_ACCOUNT_NAME:
        description: 'Azure Blob Storage Account name'
        required: true
        type: string
      AZURE_SEARCH_INDEX:
        description: 'Azure Search index name (optional - will auto-detect from search service if not provided)'
        required: false
        type: string
      WAF:
        description: 'Is this a WAF deployment? (enables public access temporarily for data import and then disables it)'
        required: false
        type: boolean
        default: false

jobs:
  import-sample-data-cosmosdb:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Validate Workflow Input Parameters
        shell: bash
        env:
          INPUT_RESOURCE_GROUP_NAME: ${{ inputs.RESOURCE_GROUP_NAME }}
          INPUT_AZURE_SEARCH_SERVICE: ${{ inputs.AZURE_SEARCH_SERVICE }}
          INPUT_AZURE_BLOB_ACCOUNT_NAME: ${{ inputs.AZURE_BLOB_ACCOUNT_NAME }}
          INPUT_AZURE_SEARCH_INDEX: ${{ inputs.AZURE_SEARCH_INDEX }}
          INPUT_WAF: ${{ inputs.WAF }}
        run: |
          echo "üîç Validating workflow input parameters..."
          VALIDATION_FAILED=false

          # Validate RESOURCE_GROUP_NAME (required, Azure naming convention)
          if [[ -z "$INPUT_RESOURCE_GROUP_NAME" ]]; then
            echo "‚ùå ERROR: RESOURCE_GROUP_NAME is required but not provided"
            VALIDATION_FAILED=true
          elif [[ ! "$INPUT_RESOURCE_GROUP_NAME" =~ ^[a-zA-Z0-9._\(\)-]+$ ]] || [[ "$INPUT_RESOURCE_GROUP_NAME" =~ \.$ ]]; then
            echo "‚ùå ERROR: RESOURCE_GROUP_NAME '$INPUT_RESOURCE_GROUP_NAME' is invalid. Must contain only alphanumerics, periods, underscores, hyphens, and parentheses. Cannot end with period."
            VALIDATION_FAILED=true
          elif [[ ${#INPUT_RESOURCE_GROUP_NAME} -gt 90 ]]; then
            echo "‚ùå ERROR: RESOURCE_GROUP_NAME '$INPUT_RESOURCE_GROUP_NAME' exceeds 90 characters"
            VALIDATION_FAILED=true
          else
            echo "‚úÖ RESOURCE_GROUP_NAME: '$INPUT_RESOURCE_GROUP_NAME' is valid"
          fi

          # Validate AZURE_SEARCH_SERVICE (required, can be name or URL)
          if [[ -z "$INPUT_AZURE_SEARCH_SERVICE" ]]; then
            echo "‚ùå ERROR: AZURE_SEARCH_SERVICE is required but not provided"
            VALIDATION_FAILED=true
          elif [[ "$INPUT_AZURE_SEARCH_SERVICE" == https://* ]]; then
            # Validate URL format
            if [[ ! "$INPUT_AZURE_SEARCH_SERVICE" =~ ^https://[a-zA-Z0-9-]+\.search\.windows\.net/?$ ]]; then
              echo "‚ùå ERROR: AZURE_SEARCH_SERVICE URL '$INPUT_AZURE_SEARCH_SERVICE' is invalid. Must be in format: https://<servicename>.search.windows.net"
              VALIDATION_FAILED=true
            else
              echo "‚úÖ AZURE_SEARCH_SERVICE: '$INPUT_AZURE_SEARCH_SERVICE' is valid (URL format)"
            fi
          elif [[ ! "$INPUT_AZURE_SEARCH_SERVICE" =~ ^[a-zA-Z0-9-]+$ ]]; then
            echo "‚ùå ERROR: AZURE_SEARCH_SERVICE '$INPUT_AZURE_SEARCH_SERVICE' is invalid. Must contain only alphanumerics and hyphens"
            VALIDATION_FAILED=true
          else
            echo "‚úÖ AZURE_SEARCH_SERVICE: '$INPUT_AZURE_SEARCH_SERVICE' is valid"
          fi

          # Validate AZURE_BLOB_ACCOUNT_NAME (required, can be name or URL)
          if [[ -z "$INPUT_AZURE_BLOB_ACCOUNT_NAME" ]]; then
            echo "‚ùå ERROR: AZURE_BLOB_ACCOUNT_NAME is required but not provided"
            VALIDATION_FAILED=true
          elif [[ "$INPUT_AZURE_BLOB_ACCOUNT_NAME" == https://* ]]; then
            # Validate URL format
            if [[ ! "$INPUT_AZURE_BLOB_ACCOUNT_NAME" =~ ^https://[a-z0-9]+\.blob\.core\.windows\.net/?$ ]]; then
              echo "‚ùå ERROR: AZURE_BLOB_ACCOUNT_NAME URL '$INPUT_AZURE_BLOB_ACCOUNT_NAME' is invalid. Must be in format: https://<accountname>.blob.core.windows.net"
              VALIDATION_FAILED=true
            else
              echo "‚úÖ AZURE_BLOB_ACCOUNT_NAME: '$INPUT_AZURE_BLOB_ACCOUNT_NAME' is valid (URL format)"
            fi
          elif [[ ! "$INPUT_AZURE_BLOB_ACCOUNT_NAME" =~ ^[a-z0-9]{3,24}$ ]]; then
            echo "‚ùå ERROR: AZURE_BLOB_ACCOUNT_NAME '$INPUT_AZURE_BLOB_ACCOUNT_NAME' is invalid. Must be 3-24 lowercase letters and numbers only"
            VALIDATION_FAILED=true
          else
            echo "‚úÖ AZURE_BLOB_ACCOUNT_NAME: '$INPUT_AZURE_BLOB_ACCOUNT_NAME' is valid"
          fi

          # Validate AZURE_SEARCH_INDEX (optional, alphanumeric with hyphens if provided)
          if [[ -n "$INPUT_AZURE_SEARCH_INDEX" ]]; then
            if [[ ! "$INPUT_AZURE_SEARCH_INDEX" =~ ^[a-zA-Z0-9-]+$ ]]; then
              echo "‚ùå ERROR: AZURE_SEARCH_INDEX '$INPUT_AZURE_SEARCH_INDEX' is invalid. Must contain only alphanumerics and hyphens"
              VALIDATION_FAILED=true
            else
              echo "‚úÖ AZURE_SEARCH_INDEX: '$INPUT_AZURE_SEARCH_INDEX' is valid"
            fi
          else
            echo "‚úÖ AZURE_SEARCH_INDEX: Not provided (will auto-detect)"
          fi

          # Validate WAF (boolean)
          if [[ "$INPUT_WAF" != "true" && "$INPUT_WAF" != "false" ]]; then
            echo "‚ùå ERROR: WAF must be 'true' or 'false', got: '$INPUT_WAF'"
            VALIDATION_FAILED=true
          else
            echo "‚úÖ WAF: '$INPUT_WAF' is valid"
          fi

          # Fail workflow if any validation failed
          if [[ "$VALIDATION_FAILED" == "true" ]]; then
            echo ""
            echo "‚ùå Parameter validation failed. Please correct the errors above and try again."
            exit 1
          fi

          echo ""
          echo "‚úÖ All input parameters validated successfully!"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          pip install requests azure-storage-blob azure-identity

      - name: Login to Azure
        shell: bash
        run: |
          az login --service-principal -u ${{ secrets.AZURE_CLIENT_ID }} -p ${{ secrets.AZURE_CLIENT_SECRET }} --tenant ${{ secrets.AZURE_TENANT_ID }}
          az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Upgrade Azure CLI and install extensions
        run: |
          az upgrade --yes --all
          az extension add --name storage-preview --upgrade --yes || true

      - name: Extract Service Names
        id: extract_names
        env:
          INPUT_AZURE_SEARCH_SERVICE: ${{ inputs.AZURE_SEARCH_SERVICE }}
          INPUT_AZURE_BLOB_ACCOUNT_NAME: ${{ inputs.AZURE_BLOB_ACCOUNT_NAME }}
        run: |
          # Extract Azure Search service name if full URL is provided
          AZURE_SEARCH_SERVICE_INPUT="$INPUT_AZURE_SEARCH_SERVICE"
          if [[ "$AZURE_SEARCH_SERVICE_INPUT" == https://* ]]; then
            AZURE_SEARCH_SERVICE=$(echo "$AZURE_SEARCH_SERVICE_INPUT" | sed 's|https://||' | cut -d'.' -f1)
          else
            AZURE_SEARCH_SERVICE="$AZURE_SEARCH_SERVICE_INPUT"
          fi
          echo "AZURE_SEARCH_SERVICE=$AZURE_SEARCH_SERVICE" >> $GITHUB_OUTPUT
          echo "Using Azure Search Service: $AZURE_SEARCH_SERVICE"

          # Extract Azure Blob Storage Account name if full URL is provided
          AZURE_BLOB_ACCOUNT_NAME_INPUT="$INPUT_AZURE_BLOB_ACCOUNT_NAME"
          if [[ "$AZURE_BLOB_ACCOUNT_NAME_INPUT" == https://* ]]; then
            AZURE_BLOB_ACCOUNT_NAME=$(echo "$AZURE_BLOB_ACCOUNT_NAME_INPUT" | sed 's|https://||' | cut -d'.' -f1)
          else
            AZURE_BLOB_ACCOUNT_NAME="$AZURE_BLOB_ACCOUNT_NAME_INPUT"
          fi
          echo "AZURE_BLOB_ACCOUNT_NAME=$AZURE_BLOB_ACCOUNT_NAME" >> $GITHUB_OUTPUT
          echo "Using Azure Blob Storage Account: $AZURE_BLOB_ACCOUNT_NAME"

      - name: Enable Public Access for Azure Search and Storage Account (WAF)
        if: ${{ inputs.WAF == true }}
        env:
          INPUT_RESOURCE_GROUP_NAME: ${{ inputs.RESOURCE_GROUP_NAME }}
        run: |
          AZURE_SEARCH_SERVICE="${{ steps.extract_names.outputs.AZURE_SEARCH_SERVICE }}"
          AZURE_BLOB_ACCOUNT_NAME="${{ steps.extract_names.outputs.AZURE_BLOB_ACCOUNT_NAME }}"
          RESOURCE_GROUP="$INPUT_RESOURCE_GROUP_NAME"
          SUBSCRIPTION_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"

          echo "Configuring public access for resources"

          # ========== Enable Public Access for Azure Search ==========
          echo ""
          echo "üì¶ Configuring Azure Search service: $AZURE_SEARCH_SERVICE"

          # Get the current identity configuration to preserve it during update
          echo "Getting current identity configuration..."
          IDENTITY_TYPE=$(az search service show \
            --name "$AZURE_SEARCH_SERVICE" \
            --resource-group "$RESOURCE_GROUP" \
            --query "identity.type" -o tsv 2>/dev/null || echo "None")

          echo "Current identity type: $IDENTITY_TYPE"

          # Enable public network access for Azure Search with retry logic
          echo "Enabling public network access..."

          MAX_RETRIES=5
          RETRY_DELAY=30
          SEARCH_SUCCESS=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $attempt of $MAX_RETRIES..."

            # Check if identity type contains UserAssigned (handles "UserAssigned", "SystemAssigned, UserAssigned", etc.)
            if [[ "$IDENTITY_TYPE" == *"UserAssigned"* ]]; then
              # Azure CLI doesn't support UserAssigned identity updates, use REST API instead
              echo "Using REST API to preserve UserAssigned identity configuration..."

              # Get the current service configuration to preserve identity
              CURRENT_CONFIG=$(az search service show \
                --name "$AZURE_SEARCH_SERVICE" \
                --resource-group "$RESOURCE_GROUP" \
                -o json)

              # Extract the identity block
              IDENTITY_BLOCK=$(echo "$CURRENT_CONFIG" | jq '.identity')

              # Build the PATCH request body with only the properties we want to update
              PATCH_BODY=$(jq -n \
                --argjson identity "$IDENTITY_BLOCK" \
                '{
                  "properties": {
                    "publicNetworkAccess": "enabled"
                  },
                  "identity": $identity
                }')

              echo "Sending PATCH request to update public access..."
              if az rest --method PATCH \
                --uri "https://management.azure.com/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.Search/searchServices/${AZURE_SEARCH_SERVICE}?api-version=2024-03-01-preview" \
                --body "$PATCH_BODY" 2>&1; then
                echo "‚úÖ Public access enabled for Azure Search service"
                SEARCH_SUCCESS=true
                break
              fi
            else
              if az search service update \
                --name "$AZURE_SEARCH_SERVICE" \
                --resource-group "$RESOURCE_GROUP" \
                --public-access enabled 2>&1; then
                echo "‚úÖ Public access enabled for Azure Search service"
                SEARCH_SUCCESS=true
                break
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "‚ö†Ô∏è Update failed, retrying in ${RETRY_DELAY} seconds..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          if [ "$SEARCH_SUCCESS" != "true" ]; then
            echo "‚ùå Failed to enable public access for Azure Search after $MAX_RETRIES attempts"
            exit 1
          fi

          # ========== Enable Public Access for Storage Account ==========
          echo ""
          echo "üì¶ Configuring Storage Account: $AZURE_BLOB_ACCOUNT_NAME"

          # Enable public network access
          echo "Enabling public network access..."
          az storage account update \
            --name "$AZURE_BLOB_ACCOUNT_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --public-network-access Enabled \
            --output none

          # Set default action to Allow
          echo "Setting default action to Allow..."
          az storage account update \
            --name "$AZURE_BLOB_ACCOUNT_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --default-action Allow \
            --output none

          echo "‚úÖ Public access enabled for Storage Account"
          echo ""
          echo "‚úÖ Public access enabled for Azure Search and Storage Account"

      - name: Wait for Public Access Propagation (WAF)
        if: ${{ inputs.WAF == true }}
        run: |
          echo "Waiting for public access propagation..."
          sleep 300
          echo "‚úÖ Wait complete."

      - name: Upload Document to Blob Storage to Trigger Index Creation
        env:
          INPUT_RESOURCE_GROUP_NAME: ${{ inputs.RESOURCE_GROUP_NAME }}
        run: |
          AZURE_BLOB_ACCOUNT_NAME="${{ steps.extract_names.outputs.AZURE_BLOB_ACCOUNT_NAME }}"

          echo "Uploading sample document to blob storage to trigger index creation..."

          # Get storage account key for authentication
          STORAGE_KEY=$(az storage account keys list --account-name "$AZURE_BLOB_ACCOUNT_NAME" --resource-group "$INPUT_RESOURCE_GROUP_NAME" --query '[0].value' -o tsv)

          # Upload file using Azure CLI with account key
          az storage blob upload \
            --account-name "$AZURE_BLOB_ACCOUNT_NAME" \
            --account-key "$STORAGE_KEY" \
            --container-name "documents" \
            --name "PerksPlus.pdf" \
            --file "data/PerksPlus.pdf" \
            --overwrite

          echo "‚úÖ Document uploaded to blob storage"

      - name: Wait for Index Creation and Detect Index Name
        id: detect_index
        env:
          INPUT_RESOURCE_GROUP_NAME: ${{ inputs.RESOURCE_GROUP_NAME }}
          INPUT_AZURE_SEARCH_INDEX: ${{ inputs.AZURE_SEARCH_INDEX }}
        run: |
          AZURE_SEARCH_SERVICE="${{ steps.extract_names.outputs.AZURE_SEARCH_SERVICE }}"
          AZURE_SEARCH_INDEX="$INPUT_AZURE_SEARCH_INDEX"

          # Get Azure Search admin key
          AZURE_SEARCH_KEY=$(az search admin-key show --service-name $AZURE_SEARCH_SERVICE --resource-group $INPUT_RESOURCE_GROUP_NAME --query primaryKey -o tsv)

          # If index name is provided, wait for that specific index
          if [ -n "$AZURE_SEARCH_INDEX" ]; then
            echo "Index name provided: $AZURE_SEARCH_INDEX"
            echo "Waiting for index '$AZURE_SEARCH_INDEX' to be created by the application..."
            echo "This may take a few minutes as the document is processed..."

            # Wait up to 15 minutes for the index to be created
            for i in {1..30}; do
              echo "Checking for index (attempt $i/30)..."

              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
                "https://${AZURE_SEARCH_SERVICE}.search.windows.net/indexes/${AZURE_SEARCH_INDEX}?api-version=2024-07-01" \
                -H "api-key: ${AZURE_SEARCH_KEY}")

              if [ "$HTTP_STATUS" == "200" ]; then
                echo "‚úÖ Index '$AZURE_SEARCH_INDEX' found!"
                break
              fi

              if [ $i -eq 30 ]; then
                echo "‚ö†Ô∏è Index not found after 15 minutes, proceeding anyway..."
              else
                echo "Index not found yet (HTTP $HTTP_STATUS), waiting 30 seconds..."
                sleep 30
              fi
            done
          else
            echo "No index name provided. Waiting for index to be auto-created and detecting it..."
            echo "This may take a few minutes as the document is processed..."

            # Wait up to 15 minutes for any index to be created
            for i in {1..30}; do
              echo "Checking for indexes (attempt $i/30)..."

              # List all indexes in the search service
              INDEXES_RESPONSE=$(curl -s \
                "https://${AZURE_SEARCH_SERVICE}.search.windows.net/indexes?api-version=2024-07-01&\$select=name" \
                -H "api-key: ${AZURE_SEARCH_KEY}")

              # Extract index names using jq
              INDEX_COUNT=$(echo "$INDEXES_RESPONSE" | jq -r '.value | length')

              if [ "$INDEX_COUNT" -gt 0 ]; then
                # Get the first index name (most recently created)
                AZURE_SEARCH_INDEX=$(echo "$INDEXES_RESPONSE" | jq -r '.value[0].name')
                echo "‚úÖ Found index: '$AZURE_SEARCH_INDEX'"
                break
              fi

              if [ $i -eq 30 ]; then
                echo "‚ùå No index found after 15 minutes"
                exit 1
              else
                echo "No indexes found yet, waiting 30 seconds..."
                sleep 30
              fi
            done
          fi

          echo "AZURE_SEARCH_INDEX=$AZURE_SEARCH_INDEX" >> $GITHUB_OUTPUT
          echo "Using index: $AZURE_SEARCH_INDEX"

      - name: Populate Azure Search Index
        env:
          INPUT_RESOURCE_GROUP_NAME: ${{ inputs.RESOURCE_GROUP_NAME }}
        run: |
          AZURE_SEARCH_SERVICE="${{ steps.extract_names.outputs.AZURE_SEARCH_SERVICE }}"
          AZURE_SEARCH_INDEX="${{ steps.detect_index.outputs.AZURE_SEARCH_INDEX }}"

          export AZURE_SEARCH_SERVICE
          export AZURE_SEARCH_INDEX

          # Get Azure Search admin key from Azure
          export AZURE_SEARCH_KEY=$(az search admin-key show --service-name $AZURE_SEARCH_SERVICE --resource-group $INPUT_RESOURCE_GROUP_NAME --query primaryKey -o tsv)

          echo "Populating index: $AZURE_SEARCH_INDEX"

          python - <<EOF
          import requests
          import json
          import os

          # Azure Cognitive Search details from environment
          SEARCH_SERVICE = os.environ.get("AZURE_SEARCH_SERVICE")
          INDEX_NAME = os.environ.get("AZURE_SEARCH_INDEX")
          API_KEY = os.environ.get("AZURE_SEARCH_KEY")

          # Use stable API version
          API_VERSION = "2024-07-01"

          # Search API endpoint
          ENDPOINT = f"https://{SEARCH_SERVICE}.search.windows.net/indexes/{INDEX_NAME}/docs/index?api-version={API_VERSION}"
          HEADERS = {
              "Content-Type": "application/json",
              "api-key": API_KEY
          }

          # Load exported data
          with open("data/azure_search_data.json", "r", encoding="utf-8") as f:
              documents = json.load(f)

          # Format for Azure Search bulk upload
          payload = {
              "value": [{"@search.action": "upload", **doc} for doc in documents]
          }

          print(f"Uploading {len(documents)} documents to index '{INDEX_NAME}'...")

          # Send data to Azure Search
          response = requests.post(ENDPOINT, headers=HEADERS, json=payload)

          if response.status_code in [200, 207]:
              result = response.json()
              success_count = sum(1 for item in result.get('value', []) if item.get('status', False))
              print(f"‚úÖ Import completed! {success_count}/{len(documents)} documents uploaded successfully.")
          else:
              print(f"‚ùå Failed to import data: {response.status_code}, {response.text}")
              exit(1)
          EOF

      - name: Disable Public Access for Azure Search and Storage Account (WAF)
        if: ${{ inputs.WAF == true }}
        env:
          INPUT_RESOURCE_GROUP_NAME: ${{ inputs.RESOURCE_GROUP_NAME }}
        run: |
          AZURE_SEARCH_SERVICE="${{ steps.extract_names.outputs.AZURE_SEARCH_SERVICE }}"
          AZURE_BLOB_ACCOUNT_NAME="${{ steps.extract_names.outputs.AZURE_BLOB_ACCOUNT_NAME }}"
          RESOURCE_GROUP="$INPUT_RESOURCE_GROUP_NAME"
          SUBSCRIPTION_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"

          echo "Disabling public access for resources"

          # ========== Disable Public Access for Azure Search ==========
          echo ""
          echo "üì¶ Configuring Azure Search service: $AZURE_SEARCH_SERVICE"

          # Get the current identity configuration to preserve it during update
          echo "Getting current identity configuration..."
          IDENTITY_TYPE=$(az search service show \
            --name "$AZURE_SEARCH_SERVICE" \
            --resource-group "$RESOURCE_GROUP" \
            --query "identity.type" -o tsv 2>/dev/null || echo "None")

          echo "Current identity type: $IDENTITY_TYPE"

          # Disable public network access for Azure Search with retry logic
          echo "Disabling public network access..."

          MAX_RETRIES=5
          RETRY_DELAY=30
          SEARCH_SUCCESS=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $attempt of $MAX_RETRIES..."

            # Check if identity type contains UserAssigned (handles "UserAssigned", "SystemAssigned, UserAssigned", etc.)
            if [[ "$IDENTITY_TYPE" == *"UserAssigned"* ]]; then
              # Azure CLI doesn't support UserAssigned identity updates, use REST API instead
              echo "Using REST API to preserve UserAssigned identity configuration..."

              # Get the current service configuration to preserve identity
              CURRENT_CONFIG=$(az search service show \
                --name "$AZURE_SEARCH_SERVICE" \
                --resource-group "$RESOURCE_GROUP" \
                -o json)

              # Extract the identity block
              IDENTITY_BLOCK=$(echo "$CURRENT_CONFIG" | jq '.identity')

              # Build the PATCH request body with only the properties we want to update
              PATCH_BODY=$(jq -n \
                --argjson identity "$IDENTITY_BLOCK" \
                '{
                  "properties": {
                    "publicNetworkAccess": "disabled"
                  },
                  "identity": $identity
                }')

              echo "Sending PATCH request to update public access..."
              if az rest --method PATCH \
                --uri "https://management.azure.com/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.Search/searchServices/${AZURE_SEARCH_SERVICE}?api-version=2024-03-01-preview" \
                --body "$PATCH_BODY" 2>&1; then
                echo "‚úÖ Public access disabled for Azure Search service"
                SEARCH_SUCCESS=true
                break
              fi
            else
              if az search service update \
                --name "$AZURE_SEARCH_SERVICE" \
                --resource-group "$RESOURCE_GROUP" \
                --public-access disabled 2>&1; then
                echo "‚úÖ Public access disabled for Azure Search service"
                SEARCH_SUCCESS=true
                break
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "‚ö†Ô∏è Update failed, retrying in ${RETRY_DELAY} seconds..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          if [ "$SEARCH_SUCCESS" != "true" ]; then
            echo "‚ùå Failed to disable public access for Azure Search after $MAX_RETRIES attempts"
            exit 1
          fi

          # ========== Disable Public Access for Storage Account ==========
          echo ""
          echo "üì¶ Configuring Storage Account: $AZURE_BLOB_ACCOUNT_NAME"

          # Disable public network access
          echo "Disabling public network access..."
          az storage account update \
            --name "$AZURE_BLOB_ACCOUNT_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --public-network-access Disabled \
            --output none

          # Set default action to Deny
          echo "Setting default action to Deny..."
          az storage account update \
            --name "$AZURE_BLOB_ACCOUNT_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --default-action Deny \
            --output none

          echo "‚úÖ Public access disabled for Storage Account"
          echo ""
          echo "‚úÖ Public access disabled for Azure Search and Storage Account"

      - name: Generate Test Job Summary
        if: always()
        run: |
          echo "## üìä Import Sample Data (CosmosDB) Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Job Status** | ${{ job.status == 'success' && '‚úÖ Success' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Azure Search Service** | \`${{ steps.extract_names.outputs.AZURE_SEARCH_SERVICE }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Azure Search Index** | \`${{ steps.detect_index.outputs.AZURE_SEARCH_INDEX }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Azure Blob Storage Account** | \`${{ steps.extract_names.outputs.AZURE_BLOB_ACCOUNT_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Resource Group** | \`${{ inputs.RESOURCE_GROUP_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **WAF** | \`${{ inputs.WAF }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "### ‚úÖ Import Sample Data (CosmosDB) Results" >> $GITHUB_STEP_SUMMARY
            echo "- Document uploaded to blob storage to trigger index creation" >> $GITHUB_STEP_SUMMARY
            echo "- Azure Search index populated with Sample data" >> $GITHUB_STEP_SUMMARY
            if [[ "${{ inputs.WAF }}" == "true" ]]; then
              echo "Public access enabled and then disabled after data import" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ‚ùå Import Sample Data (CosmosDB) Failed" >> $GITHUB_STEP_SUMMARY
            echo "- Check the job logs for detailed error information" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Logout from Azure
        if: always()
        shell: bash
        run: |
          az logout || true
          echo "Logged out from Azure."
