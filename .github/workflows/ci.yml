name: Validate Deployment

on:
  # push:
  #   branches:
  #     - main
  #     - dev
  #     - demo
  # schedule:
  #   - cron: '0 8,20 * * *'  # Runs at 8:00 AM and 8:00 PM GMT
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      PRINCIPAL_ID: ${{ secrets.PRINCIPAL_ID }}
      PRINCIPAL_NAME: ${{ secrets.PRINCIPAL_NAME }}
      PRINCIPAL_TYPE: 'ServicePrincipal'

    outputs:
      imageTag: ${{ steps.set-image-tag.outputs.imageTag }}
      web_url: ${{ steps.extract-urls.outputs.web_url }}
      admin_url: ${{ steps.extract-urls.outputs.admin_url }}
      DEPLOYMENT_SUCCESS: ${{ steps.final-status.outputs.DEPLOYMENT_SUCCESS }}
      resource_group: ${{ steps.check_create_rg.outputs.RESOURCE_GROUP_NAME }}
      solution_suffix: ${{ steps.generate_solution_prefix.outputs.SOLUTION_SUFFIX }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install AZD
        run: |
          set -e
          echo "Fetching deployment output..."
          # Install azd (Azure Developer CLI) - required by process_sample_data.sh
          curl -fsSL https://aka.ms/install-azd.sh | bash

      - name: Run Quota Check
        id: quota-check
        run: |
          export AZURE_CLIENT_ID=${{ secrets.AZURE_CLIENT_ID }}
          export AZURE_TENANT_ID=${{ secrets.AZURE_TENANT_ID }}
          export AZURE_CLIENT_SECRET=${{ secrets.AZURE_CLIENT_SECRET }}
          export AZURE_SUBSCRIPTION_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          export GPT_MIN_CAPACITY="150"
          export TEXT_EMBEDDING_MIN_CAPACITY="30"
          export AZURE_REGIONS="${{ vars.AZURE_REGIONS }}"

          chmod +x scripts/checkquota.sh
          if ! scripts/checkquota.sh; then
            if grep -q "No region with sufficient quota found" scripts/checkquota.sh; then
              echo "QUOTA_FAILED=true" >> $GITHUB_ENV
            fi
            exit 1
          fi

      - name: Send Notification on Quota Failure
        if: env.QUOTA_FAILED == 'true'
        run: |
          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          EMAIL_BODY=$(cat <<EOF
          {
            "body": "<p>Dear Team,</p><p>The quota check has failed, and the pipeline cannot proceed.</p><p><strong>Build URL:</strong> ${RUN_URL}</p><p>Please take necessary action.</p><p>Best regards,<br>Your Automation Team</p>"
          }
          EOF
          )

          curl -X POST "${{ secrets.LOGIC_APP_URL }}" \
            -H "Content-Type: application/json" \
            -d "$EMAIL_BODY" || echo "Failed to send notification"

      - name: Fail Pipeline if Quota Check Fails
        if: env.QUOTA_FAILED == 'true'
        run: exit 1

      - name: Set Deployment Region
        run: |
          if [ -n "$VALID_REGION" ]; then
            echo "Selected Region: $VALID_REGION"
            echo "AZURE_LOCATION=$VALID_REGION" >> $GITHUB_ENV
          else
            echo "VALID_REGION not set, using default eastus"
            echo "AZURE_LOCATION=eastus" >> $GITHUB_ENV
          fi

      - name: Generate Resource Group Name
        id: generate_rg_name
        run: |
          echo "Generating a unique resource group name..."
          ACCL_NAME="cwyd"  # Account name as specified
          SHORT_UUID=$(uuidgen | cut -d'-' -f1)
          UNIQUE_RG_NAME="arg-${ACCL_NAME}-${SHORT_UUID}"
          echo "RESOURCE_GROUP_NAME=${UNIQUE_RG_NAME}" >> $GITHUB_ENV
          echo "Generated RESOURCE_GROUP_NAME: ${UNIQUE_RG_NAME}"

      - name: Check and Create Resource Group
        id: check_create_rg
        run: |
          echo "RESOURCE_GROUP: ${{ env.RESOURCE_GROUP_NAME }}"
          set -e
          echo "Checking if resource group exists..."
          rg_exists=$(az group exists --name ${{ env.RESOURCE_GROUP_NAME }})
          if [ "$rg_exists" = "false" ]; then
            echo "Resource group does not exist. Creating..."
            az group create --name ${{ env.RESOURCE_GROUP_NAME }} --location ${{ env.AZURE_LOCATION }} --tags SecurityControl=Ignore CreatedBy="Pipeline" || { echo "Error creating resource group"; exit 1; }
          else
            echo "Resource group already exists."
          fi
          # Set output for other jobs
          echo "RESOURCE_GROUP_NAME=${{ env.RESOURCE_GROUP_NAME }}" >> $GITHUB_OUTPUT


      - name: Generate Unique Solution Prefix
        id: generate_solution_prefix
        run: |
          set -e
          COMMON_PART="pslc"
          TIMESTAMP=$(date +%s)
          UPDATED_TIMESTAMP=$(echo $TIMESTAMP | tail -c 3)
          UNIQUE_SOLUTION_SUFFIX="${COMMON_PART}${UPDATED_TIMESTAMP}"
          echo "SOLUTION_SUFFIX=${UNIQUE_SOLUTION_SUFFIX}" >> $GITHUB_ENV
          echo "SOLUTION_SUFFIX=${UNIQUE_SOLUTION_SUFFIX}" >> $GITHUB_OUTPUT
          echo "Generated SOLUTION_SUFFIX: ${UNIQUE_SOLUTION_SUFFIX}"

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set imageTag
        id: set-image-tag
        run: |
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "imageTag=latest_waf" >> $GITHUB_ENV
            echo "::set-output name=imageTag::latest_waf"
          elif [[ "${{ github.ref_name }}" == "main" ]]; then
            echo "imageTag=latest_waf" >> $GITHUB_ENV
            echo "::set-output name=imageTag::latest_waf"
          else
            echo "imageTag=${{ github.ref_name }}" >> $GITHUB_ENV
            echo "::set-output name=imageTag::${{ github.ref_name }}"
          fi

      - name: Pre-build image and deploy
        uses: devcontainers/ci@v0.3
        env:
                      AZURE_ENV_NAME: ${{ env.SOLUTION_SUFFIX }}
                      AZURE_LOCATION: ${{ env.AZURE_LOCATION }}
                      AZURE_RESOURCE_GROUP: ${{ env.RESOURCE_GROUP_NAME }}
        with:
                            push: never
                            imageName: ghcr.io/azure-samples/chat-with-your-data-solution-accelerator
                            cacheFrom: ghcr.io/azure-samples/chat-with-your-data-solution-accelerator
                            imageTag: ${{ env.imageTag }}
                            runCmd: |
                              export optional_args="./code/tests"

                              # Azure login first
                              az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
                              az account set --subscription $AZURE_SUBSCRIPTION_ID

                              # Capture deployment output to a log file
                              make ci 2>&1 | tee ci_output.log
                              make deploy 2>&1 | tee deploy_output.log

                              # Try to extract URLs from deployment logs as backup
                              echo "=== Extracting URLs from deployment logs ==="
                              grep -oE "https://[a-zA-Z0-9.-]*\.azurewebsites\.net/" deploy_output.log | sort | uniq | head -2 | tee extracted_urls.txt || echo "No URLs found in logs"

                              # Check if we have admin URL in logs
                              grep -E "Done: Deploying service adminweb" -A 2 deploy_output.log | grep -oE "https://[a-zA-Z0-9.-]*\.azurewebsites\.net/" | head -1 > log_admin_url.txt || echo "" > log_admin_url.txt

                              # Check if we have web URL in logs
                              grep -E "Done: Deploying service web" -A 2 deploy_output.log | grep -oE "https://[a-zA-Z0-9.-]*\.azurewebsites\.net/" | head -1 > log_web_url.txt || echo "" > log_web_url.txt

                              echo "URLs from logs:"
                              echo "Admin URL from logs: $(cat log_admin_url.txt)"
                              echo "Frontend URL from logs: $(cat log_web_url.txt)"
                            env: |
                              AZURE_CLIENT_ID
                              AZURE_CLIENT_SECRET
                              AZURE_TENANT_ID
                              AZURE_SUBSCRIPTION_ID
                              AZURE_ENV_NAME
                              AZURE_LOCATION
                              AZURE_RESOURCE_GROUP
                              AUTH_ENABLED=false
                              AZURE_USE_AUTHENTICATION=false
                              AZURE_ENABLE_AUTH=false
                              FORCE_NO_AUTH=true
                              ENFORCE_AUTH=false
                              REQUIRE_AUTHENTICATION=false
                              AUTHENTICATION_ENABLED=false
                              WEBSITES_AUTH_ENABLED=false
                              WEBSITE_AUTH_ENABLED=false
                              AZURE_AUTH_ENABLED=false
                              ENABLE_AUTHENTICATION=false
                              DISABLE_AUTHENTICATION=true
                              NO_AUTH=true
                              SKIP_AUTH=true
                              PRINCIPAL_ID
                              PRINCIPAL_NAME
                              PRINCIPAL_TYPE

      - name: Extract URLs from deployment
        id: extract-urls
        run: |
                      # Method 1: Check files created by Makefile
                      echo "=== Method 1: Files from Makefile ==="
                      if [ -f "frontend_url.txt" ]; then
                        WEB_URL=$(cat frontend_url.txt | tr -d '\n\r' | xargs)
                        echo "Web URL from makefile: '$WEB_URL'"
                      fi

                      if [ -f "admin_url.txt" ]; then
                        ADMIN_URL=$(cat admin_url.txt | tr -d '\n\r' | xargs)
                        echo "Admin URL from makefile: '$ADMIN_URL'"
                      fi

                      # Method 2: Check URLs extracted from logs
                      echo "=== Method 2: URLs from deployment logs ==="
                      if [ -f "log_web_url.txt" ]; then
                        LOG_WEB_URL=$(cat log_web_url.txt | tr -d '\n\r' | xargs)
                        echo "Web URL from logs: '$LOG_WEB_URL'"
                        if [ -z "$WEB_URL" ] && [ -n "$LOG_WEB_URL" ]; then
                          WEB_URL="$LOG_WEB_URL"
                        fi
                      fi

                      if [ -f "log_admin_url.txt" ]; then
                        LOG_ADMIN_URL=$(cat log_admin_url.txt | tr -d '\n\r' | xargs)
                        echo "Admin URL from logs: '$LOG_ADMIN_URL'"
                        if [ -z "$ADMIN_URL" ] && [ -n "$LOG_ADMIN_URL" ]; then
                          ADMIN_URL="$LOG_ADMIN_URL"
                        fi
                      fi

                      # Set outputs
                      if [ -n "$WEB_URL" ] && [ "$WEB_URL" != "null" ] && [ "$WEB_URL" != "" ]; then
                        echo "web_url=$WEB_URL" >> $GITHUB_OUTPUT
                        echo "FRONTEND_WEBSITE_URL=$WEB_URL" >> $GITHUB_ENV
                        echo "‚úÖ Web URL: $WEB_URL"
                      else
                        echo "web_url=" >> $GITHUB_OUTPUT
                        echo "FRONTEND_WEBSITE_URL=" >> $GITHUB_ENV
                        echo "‚ùå Frontend URL: Not found"
                      fi

                      if [ -n "$ADMIN_URL" ] && [ "$ADMIN_URL" != "null" ] && [ "$ADMIN_URL" != "" ]; then
                        echo "admin_url=$ADMIN_URL" >> $GITHUB_OUTPUT
                        echo "ADMIN_WEBSITE_URL=$ADMIN_URL" >> $GITHUB_ENV
                        echo "‚úÖ Admin URL: $ADMIN_URL"
                      else
                        echo "admin_url=" >> $GITHUB_OUTPUT
                        echo "ADMIN_WEBSITE_URL=" >> $GITHUB_ENV
                        echo "‚ùå Admin URL: Not found"
                      fi

                      # Additional debugging
                      echo "=== All Available Files ==="
                      ls -la *.txt *.log *.json 2>/dev/null || echo "No relevant files found"

      - name: Display URLs
        run: |
                      echo "Web URL: ${{ env.FRONTEND_WEBSITE_URL }}"
                      echo "Admin URL: ${{ env.ADMIN_WEBSITE_URL }}"

      - name: Disable Authentication with Script
        run: |
                chmod +x scripts/disable_auth.sh
                ./scripts/disable_auth.sh
        env:
                FRONTEND_WEBSITE_URL: ${{ env.FRONTEND_WEBSITE_URL }}
                ADMIN_WEBSITE_URL: ${{ env.ADMIN_WEBSITE_URL }}
                AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
                AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
                AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
                AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Export PostgreSQL Host Endpoint from Makefile
        run: |
                # Only extract the PostgreSQL host endpoint from Makefile output
                # Other values are hardcoded in the script
                echo "=== Extracting PostgreSQL Host Endpoint ==="

                if [ -f "pg_host.txt" ] && [ -s "pg_host.txt" ]; then
                  PG_HOST_ENDPOINT=$(cat pg_host.txt | tr -d '\n\r' | xargs)
                  echo "PG_HOST_DESTINATION=$PG_HOST_ENDPOINT" >> $GITHUB_ENV
                  echo "‚úÖ PostgreSQL Host Endpoint: $PG_HOST_ENDPOINT"
                else
                  echo "‚ùå PostgreSQL host endpoint not found in pg_host.txt"
                  echo "PG_HOST_DESTINATION=localhost" >> $GITHUB_ENV
                  echo "Warning: Using localhost as fallback"
                fi

                echo "=== PostgreSQL Configuration Summary ==="
                echo "Host Endpoint: $PG_HOST_DESTINATION"
                echo "Database: postgres (hardcoded)"
                echo "Port: 5432 (hardcoded)"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
                python-version: '3.11'

      - name: Install Python dependencies
        run: |
                pip install psycopg2-binary python-dotenv azure-identity

      - name: Populate PostgreSQL Database
        run: |
          # First, let's get the PostgreSQL admin password from Key Vault
          echo "üîß Getting PostgreSQL credentials from Azure..."

          # Get the admin password from environment variables set during deployment
          POSTGRES_ADMIN_USER="postgres"

          # Try to get the password from azd env values
          if [ -f ".env.temp" ]; then
            POSTGRES_ADMIN_PASSWORD=$(grep '^AZURE_POSTGRESQL_PASSWORD=' .env.temp | cut -d'=' -f2 | tr -d '"' | xargs)
          fi

          # If password not found, try alternative approaches
          if [ -z "$POSTGRES_ADMIN_PASSWORD" ]; then
            echo "üîç PostgreSQL password not found in .env.temp, trying Key Vault..."

            # Try to get password from Key Vault using the naming convention
            KV_NAME="kv-${SOLUTION_SUFFIX}"
            SECRET_NAME="AZURE-POSTGRESQL-PASSWORD"

            POSTGRES_ADMIN_PASSWORD=$(az keyvault secret show --vault-name "$KV_NAME" --name "$SECRET_NAME" --query value -o tsv 2>/dev/null || echo "")
          fi

          if [ -z "$POSTGRES_ADMIN_PASSWORD" ]; then
            echo "‚ùå Could not retrieve PostgreSQL admin password!"
            echo "üí° Skipping database population - this might be expected if using Azure AD authentication only"
            exit 0
          fi

          echo "‚úÖ PostgreSQL credentials obtained"

          python - <<EOF
          import os
          import psycopg2

          pg_host = os.environ.get("PG_HOST_DESTINATION", "localhost")
          postgres_user = os.environ.get("POSTGRES_ADMIN_USER", "postgres")
          postgres_password = os.environ.get("POSTGRES_ADMIN_PASSWORD", "")

          print(f"üîß Connecting to PostgreSQL host: {pg_host}")
          print(f"üîß Using admin user: {postgres_user}")

          db_params = {
              "user": postgres_user,
              "password": postgres_password,
              "host": pg_host,
              "port": "5432",
              "dbname": "postgres",
              "sslmode": "require"
          }

          csv_file = "exported_data_vector_score.csv"
          target_table = "vector_store"

          try:
              # First check if CSV file exists
              if not os.path.exists(csv_file):
                  print(f"‚ùå CSV file '{csv_file}' not found!")
                  exit(1)

              print(f"üìÅ CSV file found: {csv_file}")

              with psycopg2.connect(**db_params) as conn:
                  with conn.cursor() as cur:
                      # Check if table exists
                      cur.execute("""
                          SELECT EXISTS (
                              SELECT FROM information_schema.tables
                              WHERE table_name = %s
                          );
                      """, (target_table,))
                      table_exists = cur.fetchone()[0]

                      if not table_exists:
                          print(f"‚ùå Table '{target_table}' does not exist!")
                          print("Available tables:")
                          cur.execute("SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';")
                          tables = cur.fetchall()
                          for table in tables:
                              print(f"  - {table[0]}")

                          # Try to create the table with a basic structure
                          print(f"üîß Attempting to create table '{target_table}'...")
                          cur.execute(f"""
                              CREATE TABLE IF NOT EXISTS {target_table} (
                                  id SERIAL PRIMARY KEY,
                                  content TEXT,
                                  content_vector vector(1536),
                                  metadata JSONB,
                                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                              );
                          """)
                          conn.commit()
                          print(f"‚úÖ Table '{target_table}' created")

                      print(f"‚úÖ Table '{target_table}' exists")

                      # Check current row count
                      cur.execute(f"SELECT COUNT(*) FROM {target_table};")
                      before_count = cur.fetchone()[0]
                      print(f"üìä Rows before import: {before_count}")

                      # Import CSV data
                      with open(csv_file, "r", encoding="utf-8") as f:
                          next(f)  # Skip header
                          cur.copy_expert(f"COPY {target_table} FROM STDIN WITH CSV", f)

                      # Check row count after import
                      cur.execute(f"SELECT COUNT(*) FROM {target_table};")
                      after_count = cur.fetchone()[0]
                      imported_rows = after_count - before_count

                      print(f"üìä Rows after import: {after_count}")
                      print(f"‚úÖ Successfully imported {imported_rows} rows from '{csv_file}' into table '{target_table}'.")

                  conn.commit()

          except FileNotFoundError as e:
              print(f"‚ùå File error: {e}")
          except psycopg2.Error as e:
              print(f"‚ùå Database error: {e}")
              print(f"üí° This might be expected if the database is configured for Azure AD authentication only")
          except Exception as e:
              print(f"‚ùå Unexpected error: {e}")
          EOF
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          PG_HOST_DESTINATION: ${{ env.PG_HOST_DESTINATION }}
          SOLUTION_SUFFIX: ${{ env.SOLUTION_SUFFIX }}
          POSTGRES_ADMIN_USER: $POSTGRES_ADMIN_USER
          POSTGRES_ADMIN_PASSWORD: $POSTGRES_ADMIN_PASSWORD

      - name: Final Status Check
        id: final-status
        run: |
                      echo "=== Final Deployment Status ==="
                      echo "Frontend URL: ${{ env.FRONTEND_WEBSITE_URL }}"
                      echo "Admin URL: ${{ env.ADMIN_WEBSITE_URL }}"
                      echo ""
                      echo "üöÄ Deployment completed!"
                      echo "‚è∞ If you still see authentication errors, wait an additional 10-15 minutes."
                      echo "üîÑ Azure authentication changes can take up to 15 minutes to fully propagate."
                      echo ""
                      echo "üåê Try accessing your applications:"
                      echo "   Frontend: ${{ env.FRONTEND_WEBSITE_URL }}"
                      echo "   Admin: ${{ env.ADMIN_WEBSITE_URL }}"
                      echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT


      - name: Wait for 5 minutes for propagation
        run: sleep 300


  e2e-test:
    needs: deploy
    if: needs.deploy.outputs.DEPLOYMENT_SUCCESS == 'true'
    uses: ./.github/workflows/test-automation.yml
    with:
      web_url: ${{ needs.deploy.outputs.web_url }}
      admin_url: ${{ needs.deploy.outputs.admin_url }}


  cleanup:
    if: always()
    needs: [deploy, e2e-test]
    runs-on: ubuntu-latest

    env:
      AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      AZURE_ENV_NAME: ${{ needs.deploy.outputs.solution_suffix }}  # Get from deploy job
      AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
      imageTag: ${{ needs.deploy.outputs.imageTag }}
      AZURE_RESOURCE_GROUP: ${{ needs.deploy.outputs.resource_group }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Destroy resources
        uses: devcontainers/ci@v0.3
        with:
          push: never
          imageName: ghcr.io/azure-samples/chat-with-your-data-solution-accelerator
          imageTag: ${{ env.imageTag }}
          runCmd: make destroy
          env: |
            AZURE_CLIENT_ID
            AZURE_CLIENT_SECRET
            AZURE_TENANT_ID
            AZURE_SUBSCRIPTION_ID
            AZURE_ENV_NAME
            AZURE_LOCATION
            AZURE_RESOURCE_GROUP

      - name: Send Notification on Failure
        if: failure()
        run: |
          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          EMAIL_BODY=$(cat <<EOF
          {
            "body": "<p>Dear Team,</p><p>The CWYD Automation process has encountered an issue and has failed to complete successfully.</p><p><strong>Build URL:</strong> ${RUN_URL}</p><p>Please investigate.</p><p>Best regards,<br>Your Automation Team</p>"
          }
          EOF
          )

          curl -X POST "${{ secrets.LOGIC_APP_URL }}" \
            -H "Content-Type: application/json" \
            -d "$EMAIL_BODY" || echo "Failed to send notification"
